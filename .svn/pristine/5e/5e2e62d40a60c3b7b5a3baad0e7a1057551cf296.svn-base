
<!DOCTYPE html>
<!--
 Generated by Apache Maven Doxia at 2018-06-10
 Rendered using Reflow Maven Skin 1.1.0 (http://andriusvelykis.github.io/reflow-maven-skin)
-->
<html  xml:lang="en" lang="en">

	<head>
		<meta charset="UTF-8" />
		<title>Secondary Indexing | Apache Phoenix</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="" />
		<meta http-equiv="content-language" content="en" />

		<link href="//netdna.bootstrapcdn.com/bootswatch/2.3.2/flatly/bootstrap.min.css" rel="stylesheet" />
		<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-responsive.min.css" rel="stylesheet" />
		<link href="./css/bootswatch.css" rel="stylesheet" />
		<link href="./css/reflow-skin.css" rel="stylesheet" />

		<link href="//yandex.st/highlightjs/7.5/styles/default.min.css" rel="stylesheet" />
		
		<link href="./css/lightbox.css" rel="stylesheet" />
		
		<link href="./css/site.css" rel="stylesheet" />
		<link href="./css/print.css" rel="stylesheet" media="print" />
		
		<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
		<!--[if lt IE 9]>
			<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->



	</head>

	<body class="page-secondary_indexing project-phoenix-site" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

		<div class="navbar navbar-fixed-top">
			<div class="navbar-inner">
				<div class="container">
					<a class="btn btn-navbar" data-toggle="collapse" data-target="#top-nav-collapse">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</a>
					<a class="brand" href="index.html"><div class="xtoplogo"></div></a>
					<div class="nav-collapse collapse" id="top-nav-collapse">
						<ul class="nav pull-right">
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="index.html" title="Overview">Overview</a></li>
									<li ><a href="who_is_using.html" title="Who is Using">Who is Using</a></li>
									<li ><a href="recent.html" title="Recent Improvements">Recent Improvements</a></li>
									<li ><a href="roadmap.html" title="Roadmap">Roadmap</a></li>
									<li ><a href="news.html" title="News">News</a></li>
									<li ><a href="performance.html" title="Performance">Performance</a></li>
									<li ><a href="team.html" title="Team">Team</a></li>
									<li ><a href="resources.html" title="Presentations">Presentations</a></li>
									<li ><a href="mailing_list.html" title="Mailing Lists">Mailing Lists</a></li>
									<li ><a href="source.html" title="Source Repository">Source Repository</a></li>
									<li ><a href="issues.html" title="Issue Tracking">Issue Tracking</a></li>
									<li ><a href="download.html" title="Download">Download</a></li>
									<li ><a href="installation.html" title="Installation">Installation</a></li>
									<li class="divider"/>
									<li ><a href="contributing.html" title="How to Contribute">How to Contribute</a></li>
									<li ><a href="develop.html" title="How to Develop">How to Develop</a></li>
									<li ><a href="building_website.html" title="How to Update Website">How to Update Website</a></li>
									<li ><a href="release.html" title="How to Release">How to Release</a></li>
									<li class="divider"/>
									<li ><a href="http://www.apache.org/licenses/" title="License" class="externalLink">License</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Using <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="faq.html" title="F.A.Q.">F.A.Q.</a></li>
									<li ><a href="Phoenix-in-15-minutes-or-less.html" title="Quick Start">Quick Start</a></li>
									<li ><a href="building.html" title="Building">Building</a></li>
									<li ><a href="tuning_guide.html" title="Tuning">Tuning</a></li>
									<li ><a href="explainplan.html" title="Explain Plan">Explain Plan</a></li>
									<li ><a href="tuning.html" title="Configuration">Configuration</a></li>
									<li ><a href="upgrading.html" title="Backward Compatibility">Backward Compatibility</a></li>
									<li ><a href="release_notes.html" title="Release Notes">Release Notes</a></li>
									<li ><a href="pherf.html" title="Performance Testing">Performance Testing</a></li>
									<li class="divider"/>
									<li ><a href="phoenix_spark.html" title="Apache Spark Integration">Apache Spark Integration</a></li>
									<li ><a href="hive_storage_handler.html" title="Phoenix Storage Handler for Apache Hive">Phoenix Storage Handler for Apache Hive</a></li>
									<li ><a href="pig_integration.html" title="Apache Pig Integration">Apache Pig Integration</a></li>
									<li ><a href="phoenix_mr.html" title="Map Reduce Integration">Map Reduce Integration</a></li>
									<li ><a href="flume.html" title="Apache Flume Plugin">Apache Flume Plugin</a></li>
									<li ><a href="kafka.html" title="Apache Kafka Plugin">Apache Kafka Plugin</a></li>
									<li ><a href="python.html" title="Python Driver">Python Driver</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Addons <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="http://docs.aws.amazon.com/ElasticMapReduce/latest/ReleaseGuide/emr-phoenix.html" title="Phoenix on Amazon EMR" class="externalLink">Phoenix on Amazon EMR</a></li>
									<li ><a href="http://python-phoenixdb.readthedocs.io/en/latest" title="Phoenix Adapter for Python" class="externalLink">Phoenix Adapter for Python</a></li>
									<li ><a href="phoenix_orm.html" title="Phoenix ORM Library">Phoenix ORM Library</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Features <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="transactions.html" title="Transactions">Transactions</a></li>
									<li ><a href="udf.html" title="User-defined Functions">User-defined Functions</a></li>
									<li class="divider"/>
									<li class="active"><a href="" title="Secondary Indexes">Secondary Indexes</a></li>
									<li ><a href="columnencoding.html" title="Storage Formats">Storage Formats</a></li>
									<li ><a href="atomic_upsert.html" title="Atomic Upsert">Atomic Upsert</a></li>
									<li ><a href="namspace_mapping.html" title="Namespace Mapping">Namespace Mapping</a></li>
									<li ><a href="update_statistics.html" title="Statistics Collection">Statistics Collection</a></li>
									<li ><a href="rowtimestamp.html" title="Row Timestamp Column">Row Timestamp Column</a></li>
									<li ><a href="paged.html" title="Paged Queries">Paged Queries</a></li>
									<li ><a href="salted.html" title="Salted Tables">Salted Tables</a></li>
									<li ><a href="skip_scan.html" title="Skip Scan">Skip Scan</a></li>
									<li ><a href="tablesample.html" title="Table Sampling">Table Sampling</a></li>
									<li class="divider"/>
									<li ><a href="views.html" title="Views">Views</a></li>
									<li ><a href="multi-tenancy.html" title="Multi tenancy">Multi tenancy</a></li>
									<li ><a href="dynamic_columns.html" title="Dynamic Columns">Dynamic Columns</a></li>
									<li class="divider"/>
									<li ><a href="bulk_dataload.html" title="Bulk Loading">Bulk Loading</a></li>
									<li ><a href="server.html" title="Query Server">Query Server</a></li>
									<li ><a href="metrics.html" title="Metrics">Metrics</a></li>
									<li ><a href="tracing.html" title="Tracing">Tracing</a></li>
									<li ><a href="cursors.html" title="Cursor">Cursor</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Reference <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="language/index.html" title="Grammar">Grammar</a></li>
									<li ><a href="language/functions.html" title="Functions">Functions</a></li>
									<li ><a href="language/datatypes.html" title="Datatypes">Datatypes</a></li>
									<li ><a href="array_type.html" title="ARRAY type">ARRAY type</a></li>
									<li class="divider"/>
									<li ><a href="sequences.html" title="Sequences">Sequences</a></li>
									<li ><a href="joins.html" title="Joins">Joins</a></li>
									<li ><a href="subqueries.html" title="Subqueries">Subqueries</a></li>
									<li ><a href="explainplan.html" title="Explain Plan">Explain Plan</a></li>
								</ul>
							</li>
						</ul>
					</div><!--/.nav-collapse -->
				</div>
			</div>
		</div>
		
	<div class="container">
	
	<!-- Masthead
	================================================== -->

	<header>
	</header>

	<div class="main-body">
	<div class="row">
		<div class="span12">
			<div class="body-content">
<div class="page-header">
 <h1>Secondary Indexing</h1>
</div> 
<p>Secondary indexes are an orthogonal way to access data from its primary access path. In HBase, you have a single index that is lexicographically sorted on the primary row key. Access to records in any way other than through the primary row requires scanning over potentially all the rows in the table to test them against your filter. With secondary indexing, the columns or expressions you index form an alternate row key to allow point lookups and range scans along this new axis.</p> 
<div class="section"> 
 <h2 id="Covered_Indexes">Covered Indexes</h2> 
 <p>Phoenix is particularly powerful in that we provide <i>covered</i> indexes - we do not need to go back to the primary table once we have found the index entry. Instead, we bundle the data we care about right in the index rows, saving read-time overhead.</p> 
 <p>For example, the following would create an index on the <tt>v1</tt> and <tt>v2</tt> columns and include the <tt>v3</tt> column in the index as well to prevent having to get it from the data table:</p> 
 <div class="source"> 
  <pre>CREATE INDEX my_index ON my_table (v1,v2) INCLUDE(v3)
</pre> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="Functional_Indexes">Functional Indexes</h2> 
 <p>Functional indexes (available in 4.3 and above) allow you to create an index not just on columns, but on an arbitrary expressions. Then when a query uses that expression, the index may be used to retrieve the results instead of the data table. For example, you could create an index on <tt><small>UPPER(FIRST_NAME||‘ ’||LAST_NAME)</small></tt> to allow you to do case insensitive searches on the combined first name and last name of a person.</p> 
 <p>For example, the following would create this functional index:</p> 
 <div class="source"> 
  <pre>CREATE INDEX UPPER_NAME_IDX ON EMP (UPPER(FIRST_NAME||' '||LAST_NAME))
</pre> 
 </div> 
 <p>With this index in place, when the following query is issued, the index would be used instead of the data table to retrieve the results:</p> 
 <div class="source"> 
  <pre>SELECT EMP_ID FROM EMP WHERE UPPER(FIRST_NAME||' '||LAST_NAME)='JOHN DOE'
</pre> 
 </div> 
 <p>Phoenix supports two types of indexing techniques: global and local indexing. Each are useful in different scenarios and have their own failure profiles and performance characteristics.</p> 
</div> 
<div class="section"> 
 <h2 id="Global_Indexes">Global Indexes</h2> 
 <p>Global indexing targets <i>read heavy</i> uses cases. With global indexes, all the performance penalties for indexes occur at write time. We intercept the data table updates on write (<a href="language/index.html#delete">DELETE</a>, <a href="language/index.html#upsert_values">UPSERT VALUES</a> and <a href="language/index.html#upsert_select">UPSERT SELECT</a>), build the index update and then sent any necessary updates to all interested index tables. At read time, Phoenix will select the index table to use that will produce the fastest query time and directly scan it just like any other HBase table. By default, unless hinted, an index will not be used for a query that references a column that isn’t part of the index.</p> 
</div> 
<div class="section"> 
 <h2 id="Local_Indexes">Local Indexes</h2> 
 <p>Local indexing targets <i>write heavy</i>, <i>space constrained</i> use cases. Just like with global indexes, Phoenix will automatically select whether or not to use a local index at query-time. With local indexes, index data and table data co-reside on same server preventing any network overhead during writes. Local indexes can be used even when the query isn’t fully covered (i.e. Phoenix automatically retrieve the columns not in the index through point gets against the data table). Unlike global indexes, all local indexes of a table are stored in a single, separate shared table prior to 4.8.0 version. From 4.8.0 onwards we are storing all local index data in the separate shadow column families in the same data table. At read time when the local index is used, every region must be examined for the data as the exact region location of index data cannot be predetermined. Thus some overhead occurs at read-time.</p> 
</div> 
<div class="section"> 
 <h2 id="Index_Population">Index Population</h2> 
 <p>By default, when an index is created, it is populated synchronously during the CREATE INDEX call. This may not be feasible depending on the current size of the data table. As of 4.5, initially population of an index may be done asynchronously by including the ASYNC keyword in the index creation DDL statement:</p> 
 <div class="source"> 
  <pre>CREATE INDEX async_index ON my_schema.my_table (v) ASYNC
</pre> 
 </div> 
 <p>The map reduce job that populates the index table must be kicked off separately through the HBase command line like this:</p> 
 <div class="source"> 
  <pre>${HBASE_HOME}/bin/hbase org.apache.phoenix.mapreduce.index.IndexTool
  --schema MY_SCHEMA --data-table MY_TABLE --index-table ASYNC_IDX
  --output-path ASYNC_IDX_HFILES
</pre> 
 </div> 
 <p>Only when the map reduce job is complete will the index be activated and start to be used in queries. The job is resilient to the client being exited. The output-path option is used to specify a HDFS directory that is used for writing HFiles to.</p> 
</div> 
<div class="section"> 
 <h2 id="Index_Usage">Index Usage</h2> 
 <p>Indexes are automatically used by Phoenix to service a query when it’s determined more efficient to do so. However, a global index will not be used unless all of the columns referenced in the query are contained in the index. For example, the following query would not use the index, because v2 is referenced in the query but not included in the index:</p> 
 <div class="source"> 
  <pre>SELECT v2 FROM my_table WHERE v1 = 'foo'
</pre> 
 </div> 
 <p>There are three means of getting an index to be used in this case:</p> 
 <ol style="list-style-type: decimal"> 
  <li> <p>Create a <i>covered</i> index by including v2 in the index:</p> 
   <div> 
    <pre>
CREATE INDEX my_index ON my_table (v1) INCLUDE (v2)
</pre> 
   </div> <p>This will cause the v2 column value to be copied into the index and kept in synch as it changes. This will obviously increase the size of the index.</p></li> 
  <li> <p>Hint the query to force it to use the index:</p> 
   <div> 
    <pre>
SELECT /*+ INDEX(my_table my_index) */ v2 FROM my_table WHERE v1 = 'foo'
</pre> 
   </div> <p>This will cause each data row to be retrieved when the index is traversed to find the missing v2 column value. This hint should only be used if you know that the index has good selective (i.e. a small number of table rows have a value of ‘foo’ in this example), as otherwise you’ll get better performance by the default behavior of doing a full table scan.</p></li> 
  <li> <p>Create a <i>local</i> index:</p> 
   <div> 
    <pre>
CREATE LOCAL INDEX my_index ON my_table (v1)
</pre> 
   </div> <p>Unlike global indexes, local indexes <i>will</i> use an index even when all columns referenced in the query are not contained in the index. This is done by default for local indexes because we know that the table and index data coreside on the same region server thus ensuring the lookup is local.</p></li> 
 </ol> 
</div> 
<div class="section"> 
 <h2 id="Index_Removal">Index Removal</h2> 
 <p>To drop an index, you’d issue the following statement:</p> 
 <div class="source"> 
  <pre>DROP INDEX my_index ON my_table
</pre> 
 </div> 
 <p>If an indexed column is dropped in the data table, the index will automatically be dropped. In addition, if a covered column is dropped in the data table, it will be automatically dropped from the index as well.</p> 
</div> 
<div class="section"> 
 <h2 id="Index_Properties">Index Properties</h2> 
 <p>Just like with the <tt>CREATE TABLE</tt> statement, the <tt>CREATE INDEX</tt> statement may pass through properties to apply to the underlying HBase table, including the ability to salt it:</p> 
 <div class="source"> 
  <pre>CREATE INDEX my_index ON my_table (v2 DESC, v1) INCLUDE (v3)
    SALT_BUCKETS=10, DATA_BLOCK_ENCODING='NONE'
</pre> 
 </div> 
 <p>Note that if the primary table is salted, then the index is automatically salted in the same way for global indexes. In addition, the MAX_FILESIZE for the index is adjusted down, relative to the size of the primary versus index table. For more on salting see <a href="salted.html">here</a>. With local indexes, on the other hand, specifying SALT_BUCKETS is not allowed.</p> 
</div> 
<div class="section"> 
 <h2 id="Consistency"> Consistency Guarantees<a name="Consistency_Guarantees"></a></h2> 
 <p>On successful return to the client after a commit, all data is guaranteed to be written to all interested indexes and the primary table. In other words, index updates are synchronous with the same strong consistency guarantees provided by HBase.</p> 
 <p>However, since indexes are stored in separate tables than the data table, depending on the properties of the table and the type of index, the consistency between your table and index varies in the event that a commit fails due to a server-side crash. This is an important design consideration driven by your requirements and use case.</p> 
 <p>Outlined below are the different options with various levels of consistency guarantees.</p> 
 <div class="section"> 
  <h3 id="Transactional_Tables">Transactional Tables</h3> 
  <p>By declaring your table as <a href="transactions.html">transactional</a>, you achieve the highest level of consistency guarantee between your table and index. In this case, your commit of your table mutations and related index updates are atomic with strong <a class="externalLink" href="https://en.wikipedia.org/wiki/ACID">ACID</a> guarantees. If the commit fails, then none of your data (table or index) is updated, thus ensuring that your table and index are always in sync.</p> 
  <p>Why not just always declare your tables as transactional? This may be fine, especially if your table is declared as immutable, since the transactional overhead is very small in this case. However, if your data is mutable, make sure that the overhead associated with the conflict detection that occurs with transactional tables and the operational overhead of running the transaction manager is acceptable. Additionally, transactional tables with secondary indexes potentially lowers your availability of being able to write to your data table, as both the data table and its secondary index tables must be availalbe as otherwise the write will fail.</p> 
 </div> 
 <div class="section"> 
  <h3 id="Immutable_Tables">Immutable Tables</h3> 
  <p>For a table in which the data is only written once and never updated in-place, certain optimizations may be made to reduce the write-time overhead for incremental maintenance. This is common with time-series data such as log or event data, where once a row is written, it will never be updated. To take advantage of these optimizations, declare your table as immutable by adding the <tt>IMMUTABLE_ROWS=true</tt> property to your DDL statement:</p> 
  <div class="source"> 
   <pre>CREATE TABLE my_table (k VARCHAR PRIMARY KEY, v VARCHAR) IMMUTABLE_ROWS=true
</pre> 
  </div> 
  <p>All indexes on a table declared with <tt>IMMUTABLE_ROWS=true</tt> are considered immutable (note that by default, tables are considered mutable). For global immutable indexes, the index is maintained entirely on the client-side with the index table being generated as changes to the data table occur. Local immutable indexes, on the other hand, are maintained on the server-side. Note that no safeguards are in-place to enforce that a table declared as immutable doesn’t actually mutate data (as that would negate the performance gain achieved). If that was to occur, the index would no longer be in sync with the table.</p> 
  <p>If you have an existing table that you’d like to switch from immutable indexing to mutable indexing, use the <tt>ALTER TABLE</tt> command as show below:</p> 
  <div class="source"> 
   <pre>ALTER TABLE my_table SET IMMUTABLE_ROWS=false
</pre> 
  </div> 
  <p>Index on non transactional, immutable tables have no mechanism in place to automatically deal with a commit failure. Maintaining consistency between the table and index is left to the client to handle. Because the updates are idempotent, the simplest solution is for the client to continue retrying the batch of mutations until they succeed.</p> 
 </div> 
 <div class="section"> 
  <h3 id="Mutable_Tables">Mutable Tables</h3> 
  <p>For non transactional mutable tables, we maintain index update durability by adding the index updates to the Write-Ahead-Log (WAL) entry of the primary table row. Only after the WAL entry is successfully synced to disk do we attempt to make the index/primary table updates. We write the index updates in parallel by default, leading to very high throughput. If the server crashes while we are writing the index updates, we replay the all the index updates to the index tables in the WAL recovery process and rely on the idempotence of the updates to ensure correctness. Therefore, indexes on non transactional mutable tables are only ever a single batch of edits behind the primary table.</p> 
  <p>It’s important to note several points:</p> 
  <ul> 
   <li>For non transactional tables, you could see the index table out of sync with the primary table.</li> 
   <li>As noted above, this is ok as we are only a very small bit behind and out of sync for very short periods</li> 
   <li>Each data row and its index row(s) are guaranteed to to be written or lost - we never see partial updates as this is part of the atomicity guarantees of HBase.</li> 
   <li>Data is first written to the table followed by the index tables (the reverse is true if the WAL is disabled).</li> 
  </ul> 
  <div class="section"> 
   <h4 id="Singular_Write_Path">Singular Write Path</h4> 
   <p>There is a single write path that guarantees the failure properties. All writes to the HRegion get intercepted by our coprocessor. We then build the index updates based on the pending update (or updates, in the case of the batch). These update are then appended to the WAL entry for the original update.</p> 
   <p>If we get any failure up to this point, we return the failure to the client and no data is persisted or made visible to the client. </p> 
   <p>Once the WAL is written, we ensure that the index and primary table data will become visible, even in the case of a failure.</p> 
   <ul> 
    <li>If the server <i>does</i> crash, we then replay the index updates with the usual WAL replay mechanism</li> 
    <li>If the server does <i>not</i> crash, we just insert the index updates to their respective tables. 
     <ul> 
      <li>If the index updates fail, the various means of maintaining consistency are outlined below.</li> 
      <li>If the Phoenix system catalog table cannot be reached when a failure occurs, we force the server to be immediately aborted and failing this, call System.exit on the JVM, forcing the server to die. By killing the server, we ensure that the WAL will be replayed on recovery, replaying the index updates to their appropriate tables. This ensures that a secondary index is not continued to be used when it’s in a know, invalid state.</li> 
     </ul></li> 
   </ul> 
  </div> 
  <div class="section"> 
   <h4 id="Disallow_table_writes_until_mutable_index_is_consistent">Disallow table writes until mutable index is consistent</h4> 
   <p>The highest level of maintaining consistency between your non transactional table and index is to declare that writes to the data table should be temporarily disallowed in the event of a failure to update the index. In this consistency mode, the table and index will be held at the timestamp before the failure occurred, with writes to the data table being disallowed until the index is back online and in-sync with the data table. The index will remain active and continue to be used by queries as usual.</p> 
   <p>The following server-side configurations control this behavior:</p> 
   <ul> 
    <li><tt>phoenix.index.failure.block.write</tt> must be true to enable a writes to the data table to fail in the event of a commit failure until the index can be caught up with the data table.</li> 
    <li><tt>phoenix.index.failure.handling.rebuild</tt> must be true (the default) to enable a mutable index to be rebuilt in the background in the event of a commit failure.</li> 
   </ul> 
  </div> 
  <div class="section"> 
   <h4 id="Disable_mutable_indexes_on_write_failure_until_consistency_restored">Disable mutable indexes on write failure until consistency restored</h4> 
   <p>The default behavior with mutable indexes is to mark the index as disabled if a write to them fails at commit time, partially rebuild them in the background, and then mark them as active again once consistency is restored. In this consistency mode, writes to the data table will not be blocked while the secondary index is being rebuilt. However, the secondary index will not be used by queries while the rebuild is happening.</p> 
   <p>The following server-side configurations control this behavior:</p> 
   <ul> 
    <li><tt>phoenix.index.failure.handling.rebuild</tt> must be true (the default) to enable a mutable index to be rebuilt in the background in the event of a commit failure.</li> 
    <li><tt>phoenix.index.failure.handling.rebuild.interval</tt> controls the millisecond frequency at which the server checks whether or not a mutable index needs to be partially rebuilt to catch up with updates to the data table. The default is 10000 or 10 seconds.</li> 
    <li><tt>phoenix.index.failure.handling.rebuild.overlap.time</tt> controls how many milliseconds to go back from the timestamp at which the failure occurred to go back when a partial rebuild is performed. The default is 1.</li> 
   </ul> 
  </div> 
  <div class="section"> 
   <h4 id="Disable_mutable_index_on_write_failure_with_manual_rebuild_required">Disable mutable index on write failure with manual rebuild required</h4> 
   <p>This is the lowest level of consistency for mutable secondary indexes. In this case, when a write to a secondary index fails, the index will be marked as disabled with a manual <a class="externalLink" href="http://phoenix.apache.org/language/index.html#alter_index">rebuild of the index</a> required to enable it to be used once again by queries.</p> 
   <p>The following server-side configurations controls this behavior:</p> 
   <ul> 
    <li><tt>phoenix.index.failure.handling.rebuild</tt> must be set to false to disable a mutable index from being rebuilt in the background in the event of a commit failure.</li> 
   </ul> 
  </div> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="Setup">Setup</h2> 
 <p>Non transactional, mutable indexing requires special configuration options on the region server and master to run - Phoenix ensures that they are setup correctly when you enable mutable indexing on the table; if the correct properties are not set, you will not be able to use secondary indexing. After adding these settings to your hbase-site.xml, you’ll need to do a rolling restart of your cluster.</p> 
 <p>You will need to add the following parameters to <tt>hbase-site.xml</tt> on each region server:</p> 
 <div class="source"> 
  <pre>&lt;property&gt;
  &lt;name&gt;hbase.regionserver.wal.codec&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.IndexedWALEditCodec&lt;/value&gt;
&lt;/property&gt;
</pre> 
 </div> 
 <p>The above property enables custom WAL edits to be written, ensuring proper writing/replay of the index updates. This codec supports the usual host of WALEdit options, most notably WALEdit compression.</p> 
 <div class="source"> 
  <pre>&lt;property&gt;
  &lt;name&gt;hbase.region.server.rpc.scheduler.factory.class&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.ipc.PhoenixRpcSchedulerFactory&lt;/value&gt;
  &lt;description&gt;Factory to create the Phoenix RPC Scheduler that uses separate queues for index and metadata updates&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.rpc.controllerfactory.class&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.ipc.controller.ServerRpcControllerFactory&lt;/value&gt;
  &lt;description&gt;Factory to create the Phoenix RPC Scheduler that uses separate queues for index and metadata updates&lt;/description&gt;
&lt;/property&gt;
</pre> 
 </div> 
 <p>The above properties prevent deadlocks from occurring during index maintenance for global indexes (HBase 0.98.4+ and Phoenix 4.3.1+ only) by ensuring index updates are processed with a higher priority than data updates. It also prevents deadlocks by ensuring metadata rpc calls are processed with a higher priority than data rpc calls.</p> 
 <p>From Phoenix 4.8.0 onward, no configuration changes are required to use local indexing. In Phoenix 4.7 and below, the following configuration changes are required to the server-side hbase-site.xml on the master and regions server nodes:</p> 
 <div class="source"> 
  <pre>&lt;property&gt;
  &lt;name&gt;hbase.master.loadbalancer.class&lt;/name&gt;
  &lt;value&gt;org.apache.phoenix.hbase.index.balancer.IndexLoadBalancer&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
  &lt;value&gt;org.apache.phoenix.hbase.index.master.IndexMasterObserver&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.regionserver.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.regionserver.LocalIndexMerger&lt;/value&gt;
&lt;/property&gt;
</pre> 
 </div> 
 <div class="section"> 
  <h3 id="Upgrading_Local_Indexes_created_before_4.8.0">Upgrading Local Indexes created before 4.8.0</h3> 
  <p>While upgrading the Phoenix to 4.8.0+ version at server remove above three local indexing related configurations from <tt>hbase-site.xml</tt> if present. From client we are supporting both online(while initializing the connection from phoenix client of 4.8.0+ versions) and offline(using psql tool) upgrade of local indexes created before 4.8.0. As part of upgrade we recreate the local indexes in ASYNC mode. After upgrade user need to build the indexes using <a class="externalLink" href="http://phoenix.apache.org/secondary_indexing.html#Index_Population">IndexTool</a></p> 
  <p>Following client side configuration used in the upgrade. </p> 
  <ol style="list-style-type: decimal"> 
   <li><tt>phoenix.client.localIndexUpgrade</tt> 
    <ul> 
     <li>The value of it is true means online upgrade and false means offline upgrade.</li> 
     <li><b>Default: true</b></li> 
    </ul></li> 
  </ol> 
  <p>Command to run offline upgrade using psql tool <tt>$ psql [zookeeper] -l</tt></p> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="Tuning">Tuning</h2> 
 <p>Out the box, indexing is pretty fast. However, to optimize for your particular environment and workload, there are several properties you can tune.</p> 
 <p>All the following parameters must be set in <tt>hbase-site.xml</tt> - they are true for the entire cluster and all index tables, as well as across all regions on the same server (so, for instance, a single server would not write to too many different index tables at once).</p> 
 <ol style="list-style-type: decimal"> 
  <li>index.builder.threads.max 
   <ul> 
    <li>Number of threads to used to build the index update from the primary table update</li> 
    <li>Increasing this value overcomes the bottleneck of reading the current row state from the underlying HRegion. Tuning this value too high will just bottleneck at the HRegion as it will not be able to handle too many concurrent scan requests as well as general thread-swapping concerns.</li> 
    <li><b>Default: 10</b></li> 
   </ul></li> 
  <li>index.builder.threads.keepalivetime 
   <ul> 
    <li>Amount of time in seconds after we expire threads in the builder thread pool.</li> 
    <li>Unused threads are immediately released after this amount of time and not core threads are retained (though this last is a small concern as tables are expected to sustain a fairly constant write load), but simultaneously allows us to drop threads if we are not seeing the expected load.</li> 
    <li><b>Default: 60</b></li> 
   </ul></li> 
  <li>index.writer.threads.max 
   <ul> 
    <li>Number of threads to use when writing to the target index tables.</li> 
    <li>The first level of parallelization, on a per-table basis - it should roughly correspond to the number of index tables</li> 
    <li><b>Default: 10</b></li> 
   </ul></li> 
  <li>index.writer.threads.keepalivetime 
   <ul> 
    <li>Amount of time in seconds after we expire threads in the writer thread pool.</li> 
    <li>Unused threads are immediately released after this amount of time and not core threads are retained (though this last is a small concern as tables are expected to sustain a fairly constant write load), but simultaneously allows us to drop threads if we are not seeing the expected load.</li> 
    <li><b>Default: 60</b></li> 
   </ul></li> 
  <li>hbase.htable.threads.max 
   <ul> 
    <li>Number of threads each index HTable can use for writes.</li> 
    <li>Increasing this allows more concurrent index updates (for instance across batches), leading to high overall throughput.</li> 
    <li><b>Default: 2,147,483,647</b></li> 
   </ul></li> 
  <li>hbase.htable.threads.keepalivetime 
   <ul> 
    <li>Amount of time in seconds after we expire threads in the HTable’s thread pool.</li> 
    <li>Using the “direct handoff” approach, new threads will only be created if it is necessary and will grow unbounded. This could be bad but HTables only create as many Runnables as there are region servers; therefore, it also scales when new region servers are added.</li> 
    <li><b>Default: 60</b></li> 
   </ul></li> 
  <li>index.tablefactory.cache.size 
   <ul> 
    <li>Number of index HTables we should keep in cache.</li> 
    <li>Increasing this number ensures that we do not need to recreate an HTable for each attempt to write to an index table. Conversely, you could see memory pressure if this value is set too high.</li> 
    <li><b>Default: 10</b></li> 
   </ul></li> 
  <li>org.apache.phoenix.regionserver.index.priority.min 
   <ul> 
    <li>Value to specify to bottom (inclusive) of the range in which index priority may lie.</li> 
    <li><b>Default: 1000</b></li> 
   </ul></li> 
  <li>org.apache.phoenix.regionserver.index.priority.max 
   <ul> 
    <li>Value to specify to top (exclusive) of the range in which index priority may lie.</li> 
    <li>Higher priorites within the index min/max range do not means updates are processed sooner.</li> 
    <li><b>Default: 1050</b></li> 
   </ul></li> 
  <li>org.apache.phoenix.regionserver.index.handler.count 
   <ul> 
    <li>Number of threads to use when serving index write requests for global index maintenance.</li> 
    <li>Though the actual number of threads is dictated by the Max(number of call queues, handler count), where the number of call queues is determined by standard HBase configuration. To further tune the queues, you can adjust the standard rpc queue length parameters (currently, there are no special knobs for the index queues), specifically <tt>ipc.server.max.callqueue.length</tt> and <tt>ipc.server.callqueue.handler.factor</tt>. See the <a class="externalLink" href="http://hbase.apache.org/book.html">HBase Reference Guide</a> for more details.</li> 
    <li><b>Default: 30</b></li> 
   </ul></li> 
 </ol> 
</div> 
<div class="section"> 
 <h2 id="Performance">Performance</h2> 
 <p>We track secondary index performance via our <a class="externalLink" href="http://phoenix-bin.github.io/client/performance/latest.htm">performance framework</a>. This is a generic test of performance based on defaults - your results will vary based on hardware specs as well as you individual configuration.</p> 
 <p>That said, we have seen secondary indexing (both immutable and mutable) go as quickly as &lt; 2x the regular write path on a small, (3 node) desktop-based cluster. This is actually pretty reasonable as we have to write to multiple tables as well as build the index update.</p> 
</div> 
<div class="section"> 
 <h2 id="Index_Scrutiny_Tool">Index Scrutiny Tool</h2> 
 <p>With Phoenix 4.12, there is now a tool to run a MapReduce job to verify that an index table is valid against its data table. The only way to find orphaned rows in either table is to scan over all rows in the table and do a lookup in the other table for the corresponding row. For that reason, the tool can run with either the data or index table as the “source” table, and the other as the “target” table. The tool writes all invalid rows it finds either to file or to an output table PHOENIX_INDEX_SCRUTINY. An invalid row is a source row that either has no corresponding row in the target table, or has an incorrect value in the target table (i.e. covered column value).</p> 
 <p>The tool has job counters that track its status. <tt>VALID_ROW_COUNT</tt>, <tt>INVALID_ROW_COUNT</tt>, <tt>BAD_COVERED_COL_VAL_COUNT</tt>. Note that invalid rows - bad col val rows = number of orphaned rows. These counters are written to the table PHOENIX_INDEX_SCRUTINY_METADATA, along with other job metadata.</p> 
 <p>The Index Scrutiny Tool can be launched via the <tt>hbase</tt> command (in hbase/bin) as follows:</p> 
 <div class="source"> 
  <pre>hbase org.apache.phoenix.mapreduce.index.IndexScrutinyTool -dt my_table -it my_index -o
</pre> 
 </div> 
 <p>It can also be run from Hadoop using either the phoenix-core or phoenix-server jar as follows:</p> 
 <div class="source"> 
  <pre>HADOOP_CLASSPATH=$(hbase mapredcp) hadoop jar phoenix-&lt;version&gt;-server.jar org.apache.phoenix.mapreduce.index.IndexScrutinyTool -dt my_table -it my_index -o
</pre> 
 </div> 
 <p>By default two mapreduce jobs are launched, one with the data table as the source table and one with the index table as the source table.</p> 
 <p>The following parameters can be used with the Index Scrutiny Tool:</p> 
 <table border="0" class="bodyTable table table-striped table-hover"> 
  <thead> 
   <tr class="a"> 
    <th><i>Parameter</i> </th> 
    <th><i>Description</i> </th> 
   </tr> 
  </thead> 
  <tbody> 
   <tr class="b"> 
    <td>-dt,–data-table </td> 
    <td>Data table name (mandatory) </td> 
   </tr> 
   <tr class="a"> 
    <td>-it,–index-table </td> 
    <td>Index table name (mandatory) </td> 
   </tr> 
   <tr class="b"> 
    <td>-s,–schema </td> 
    <td>Phoenix schema name (optional) </td> 
   </tr> 
   <tr class="a"> 
    <td>-src,–source </td> 
    <td>DATA_TABLE_SOURCE, INDEX_TABLE_SOURCE, or BOTH. Defaults to BOTH </td> 
   </tr> 
   <tr class="b"> 
    <td>-o,–output </td> 
    <td>Whether to output invalid rows. Off by default </td> 
   </tr> 
   <tr class="a"> 
    <td>-of,–output-format </td> 
    <td>TABLE or FILE output format. Defaults to TABLE </td> 
   </tr> 
   <tr class="b"> 
    <td>-om,–output-max </td> 
    <td>Maximum number of invalid rows to output per mapper. Defaults to 1M </td> 
   </tr> 
   <tr class="a"> 
    <td>-op,–output-path </td> 
    <td>For FILE output format, the HDFS directory where files are written</td> 
   </tr> 
   <tr class="b"> 
    <td>-t,–time </td> 
    <td>Timestamp in millis at which to run the scrutiny. This is important so that incoming writes don’t throw off the scrutiny. Defaults to current time minus 60 seconds </td> 
   </tr> 
   <tr class="a"> 
    <td>-b,–batch-size </td> 
    <td>Number of rows to compare at a time </td> 
   </tr> 
  </tbody> 
 </table> 
 <div class="section"> 
  <h3 id="Limitations">Limitations</h3> 
  <ul> 
   <li>If rows are actively being updated or deleted while the scrutiny is running, the tool may give you false positives for inconsistencies (<a class="externalLink" href="https://issues.apache.org/jira/browse/PHOENIX-4277">PHOENIX-4277</a>).</li> 
   <li>Snapshot reads are not supported by the scrutiny tool (<a class="externalLink" href="https://issues.apache.org/jira/browse/PHOENIX-4270">PHOENIX-4270</a>).</li> 
  </ul> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="Resources">Resources</h2> 
 <p>There have been several presentations given on how secondary indexing works in Phoenix that have a more in-depth look at how indexing works (with pretty pictures!):</p> 
 <ul> 
  <li><a class="externalLink" href="http://files.meetup.com/1350427/PhoenixIndexing-SF-HUG_09-26-13.pptx">San Francisco HBase Meetup</a> - Sept. 26, 2013</li> 
  <li><a class="externalLink" href="http://www.slideshare.net/jesse_yates/phoenix-secondary-indexing-la-hug-sept-9th-2013">Los Anglees HBase Meetup</a> - Sept, 4th, 2013</li> 
  <li><a class="externalLink" href="https://github.com/Huawei-Hadoop/hindex/blob/master/README.md#how-it-works">Local Indexes</a> by Huawei</li> 
  <li><a class="externalLink" href="https://issues.apache.org/jira/browse/PHOENIX-938">PHOENIX-938</a> and <a class="externalLink" href="https://issues.apache.org/jira/browse/HBASE-11513">HBASE-11513</a> for deadlock prevention during global index maintenance.</li> 
  <li><a class="externalLink" href="https://issues.apache.org/jira/browse/PHOENIX-1112">PHOENIX-1112: Atomically rebuild index partially when index update fails</a></li> 
 </ul> 
</div>
			</div>
		</div>
	</div>
	</div>

	</div><!-- /container -->
	
	<!-- Footer
	================================================== -->
	<footer class="well">
		<div class="container">
			<div class="row">
				<div class="span2 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">About</li>
						<li >
							<a href="index.html" title="Overview">Overview</a>
						</li>
						<li >
							<a href="who_is_using.html" title="Who is Using">Who is Using</a>
						</li>
						<li >
							<a href="recent.html" title="Recent Improvements">Recent Improvements</a>
						</li>
						<li >
							<a href="roadmap.html" title="Roadmap">Roadmap</a>
						</li>
						<li >
							<a href="news.html" title="News">News</a>
						</li>
						<li >
							<a href="performance.html" title="Performance">Performance</a>
						</li>
						<li >
							<a href="team.html" title="Team">Team</a>
						</li>
						<li >
							<a href="resources.html" title="Presentations">Presentations</a>
						</li>
						<li >
							<a href="mailing_list.html" title="Mailing Lists">Mailing Lists</a>
						</li>
						<li >
							<a href="source.html" title="Source Repository">Source Repository</a>
						</li>
						<li >
							<a href="issues.html" title="Issue Tracking">Issue Tracking</a>
						</li>
						<li >
							<a href="download.html" title="Download">Download</a>
						</li>
						<li >
							<a href="installation.html" title="Installation">Installation</a>
						</li>
						<li >
							<a href="http:divider" title=""></a>
						</li>
						<li >
							<a href="contributing.html" title="How to Contribute">How to Contribute</a>
						</li>
						<li >
							<a href="develop.html" title="How to Develop">How to Develop</a>
						</li>
						<li >
							<a href="building_website.html" title="How to Update Website">How to Update Website</a>
						</li>
						<li >
							<a href="release.html" title="How to Release">How to Release</a>
						</li>
						<li >
							<a href="http:divider" title=""></a>
						</li>
						<li >
							<a href="http://www.apache.org/licenses/" title="License" class="externalLink">License</a>
						</li>
					</ul>
				</div>
				<div class="span2 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Using</li>
						<li >
							<a href="faq.html" title="F.A.Q.">F.A.Q.</a>
						</li>
						<li >
							<a href="Phoenix-in-15-minutes-or-less.html" title="Quick Start">Quick Start</a>
						</li>
						<li >
							<a href="building.html" title="Building">Building</a>
						</li>
						<li >
							<a href="tuning_guide.html" title="Tuning">Tuning</a>
						</li>
						<li >
							<a href="explainplan.html" title="Explain Plan">Explain Plan</a>
						</li>
						<li >
							<a href="tuning.html" title="Configuration">Configuration</a>
						</li>
						<li >
							<a href="upgrading.html" title="Backward Compatibility">Backward Compatibility</a>
						</li>
						<li >
							<a href="release_notes.html" title="Release Notes">Release Notes</a>
						</li>
						<li >
							<a href="pherf.html" title="Performance Testing">Performance Testing</a>
						</li>
						<li >
							<a href="http:divider" title=""></a>
						</li>
						<li >
							<a href="phoenix_spark.html" title="Apache Spark Integration">Apache Spark Integration</a>
						</li>
						<li >
							<a href="hive_storage_handler.html" title="Phoenix Storage Handler for Apache Hive">Phoenix Storage Handler for Apache Hive</a>
						</li>
						<li >
							<a href="pig_integration.html" title="Apache Pig Integration">Apache Pig Integration</a>
						</li>
						<li >
							<a href="phoenix_mr.html" title="Map Reduce Integration">Map Reduce Integration</a>
						</li>
						<li >
							<a href="flume.html" title="Apache Flume Plugin">Apache Flume Plugin</a>
						</li>
						<li >
							<a href="kafka.html" title="Apache Kafka Plugin">Apache Kafka Plugin</a>
						</li>
						<li >
							<a href="python.html" title="Python Driver">Python Driver</a>
						</li>
					</ul>
				</div>
				<div class="span2 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Features</li>
						<li >
							<a href="transactions.html" title="Transactions">Transactions</a>
						</li>
						<li >
							<a href="udf.html" title="User-defined Functions">User-defined Functions</a>
						</li>
						<li >
							<a href="http:divider" title=""></a>
						</li>
						<li class="active">
							<a href="#" title="Secondary Indexes">Secondary Indexes</a>
						</li>
						<li >
							<a href="columnencoding.html" title="Storage Formats">Storage Formats</a>
						</li>
						<li >
							<a href="atomic_upsert.html" title="Atomic Upsert">Atomic Upsert</a>
						</li>
						<li >
							<a href="namspace_mapping.html" title="Namespace Mapping">Namespace Mapping</a>
						</li>
						<li >
							<a href="update_statistics.html" title="Statistics Collection">Statistics Collection</a>
						</li>
						<li >
							<a href="rowtimestamp.html" title="Row Timestamp Column">Row Timestamp Column</a>
						</li>
						<li >
							<a href="paged.html" title="Paged Queries">Paged Queries</a>
						</li>
						<li >
							<a href="salted.html" title="Salted Tables">Salted Tables</a>
						</li>
						<li >
							<a href="skip_scan.html" title="Skip Scan">Skip Scan</a>
						</li>
						<li >
							<a href="tablesample.html" title="Table Sampling">Table Sampling</a>
						</li>
						<li >
							<a href="http:divider" title=""></a>
						</li>
						<li >
							<a href="views.html" title="Views">Views</a>
						</li>
						<li >
							<a href="multi-tenancy.html" title="Multi tenancy">Multi tenancy</a>
						</li>
						<li >
							<a href="dynamic_columns.html" title="Dynamic Columns">Dynamic Columns</a>
						</li>
						<li >
							<a href="http:divider" title=""></a>
						</li>
						<li >
							<a href="bulk_dataload.html" title="Bulk Loading">Bulk Loading</a>
						</li>
						<li >
							<a href="server.html" title="Query Server">Query Server</a>
						</li>
						<li >
							<a href="metrics.html" title="Metrics">Metrics</a>
						</li>
						<li >
							<a href="tracing.html" title="Tracing">Tracing</a>
						</li>
						<li >
							<a href="cursors.html" title="Cursor">Cursor</a>
						</li>
					</ul>
				</div>
				<div class="span3 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Reference</li>
						<li >
							<a href="language/index.html" title="Grammar">Grammar</a>
						</li>
						<li >
							<a href="language/functions.html" title="Functions">Functions</a>
						</li>
						<li >
							<a href="language/datatypes.html" title="Datatypes">Datatypes</a>
						</li>
						<li >
							<a href="array_type.html" title="ARRAY type">ARRAY type</a>
						</li>
						<li >
							<a href="http:divider" title=""></a>
						</li>
						<li >
							<a href="sequences.html" title="Sequences">Sequences</a>
						</li>
						<li >
							<a href="joins.html" title="Joins">Joins</a>
						</li>
						<li >
							<a href="subqueries.html" title="Subqueries">Subqueries</a>
						</li>
						<li >
							<a href="explainplan.html" title="Explain Plan">Explain Plan</a>
						</li>
					</ul>
				</div>
				<div class="span3 bottom-description">
					<form action="http://search-hadoop.com/?" method="get"><input value="Phoenix" name="fc_project" type="hidden"><input placeholder="Search Phoenix&hellip;" required="required" style="width:170px;" size="18" name="q" id="query" type="search"></form>
				</div>
			</div>
		</div>
	</footer>
		
	<div class="container subfooter">
		<div class="row">
			<div class="span12">
				<p class="pull-right"><a href="#">Back to top</a></p>
				<p class="copyright">Copyright &copy;2018 <a href="http://www.apache.org">Apache Software Foundation</a>. All Rights Reserved.</p>
			</div>
		</div>
	</div>

	<!-- Le javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
	
	<script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
	<script src="./js/lightbox.js"></script>
	<script src="./js/jquery.smooth-scroll.min.js"></script>
	<!-- back button support for smooth scroll -->
	<script src="./js/jquery.ba-bbq.min.js"></script>
	<script src="//yandex.st/highlightjs/7.5/highlight.min.js"></script>

	<script src="./js/reflow-skin.js"></script>
	
	</body>
</html>
